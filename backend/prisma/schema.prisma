generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id @default(uuid())
  username  String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  bots      Bot[]
  workflows Workflow[]
}

model Bot {
  id              String   @id @default(uuid())
  name            String
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Bot type - determines behavior and available features
  // Immutable after creation (must delete and recreate to change type)
  botType         String   @default("storage")

  // Server connection
  serverHost      String?
  serverPort      Int      @default(25565)
  serverVersion   String?  // null = auto-detect

  // Microsoft auth (email for mineflayer cache)
  microsoftEmail  String?
  isAuthenticated Boolean  @default(false)
  
  // Offline mode for LAN testing
  useOfflineAccount Boolean @default(false)
  offlineUsername   String?

  // Public visibility - allows other users to view storage contents
  isPublic        Boolean  @default(false)

  // Status
  isOnline        Boolean  @default(false)
  lastSeen        DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  storageSystems  StorageSystem[]
  requestTasks    RequestTask[]

  @@index([userId])
  @@index([isPublic])
  @@index([botType])
}

model StorageSystem {
  id        String   @id @default(uuid())
  name      String
  botId     String
  bot       Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)

  // Center coordinates
  centerX   Int
  centerY   Int
  centerZ   Int
  radius    Int      @default(32)

  // Indexing status
  isIndexed     Boolean  @default(false)
  lastIndexed   DateTime?
  indexProgress Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  chests       Chest[]
  requestTasks RequestTask[]

  @@index([botId])
}

model Chest {
  id              String        @id @default(uuid())
  storageSystemId String
  storageSystem   StorageSystem @relation(fields: [storageSystemId], references: [id], onDelete: Cascade)

  // Position
  x               Int
  y               Int
  z               Int

  // Type
  isDoubleChest   Boolean  @default(false)
  chestType       String   @default("chest")

  lastOpened      DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  items           ChestItem[]

  @@unique([storageSystemId, x, y, z])
  @@index([storageSystemId])
}

model ChestItem {
  id        String   @id @default(uuid())
  chestId   String
  chest     Chest    @relation(fields: [chestId], references: [id], onDelete: Cascade)

  slot      Int
  itemId    String
  itemName  String
  count     Int
  nbt       Json?

  // If this item is a shulker box with contents
  isShulkerBox     Boolean     @default(false)
  shulkerContents  ShulkerContent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([chestId, slot])
  @@index([chestId])
  @@index([itemId])
  @@index([itemName])
  @@index([isShulkerBox])
}

model ShulkerContent {
  id          String    @id @default(uuid())
  chestItemId String
  chestItem   ChestItem @relation(fields: [chestItemId], references: [id], onDelete: Cascade)

  slot        Int       // 0-26 for shulker box slots
  itemId      String
  itemName    String
  count       Int

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([chestItemId, slot])
  @@index([chestItemId])
  @@index([itemId])
  @@index([itemName])
}

// ============ REQUEST TASKS ============

enum TaskStatus {
  PENDING      // Waiting in queue
  IN_PROGRESS  // Currently being executed
  PAUSED       // Paused by user or waiting for decision
  COMPLETED    // Successfully completed
  FAILED       // Failed with error
  CANCELLED    // Cancelled by user
}

enum DeliveryMethod {
  DROP_TO_PLAYER  // Walk to player and drop items
  PUT_IN_CHEST    // Put items in a specified chest location
  SHULKER_DROP    // Pack in shulkers and drop to player
  SHULKER_CHEST   // Pack in shulkers and put in chest
}

enum PackingMode {
  SELECTION_ORDER // Pack items in the order they were selected
  OPTIMIZED       // Group same items together for efficient packing
}

model RequestTask {
  id              String       @id @default(uuid())
  botId           String
  bot             Bot          @relation(fields: [botId], references: [id], onDelete: Cascade)
  storageSystemId String
  storageSystem   StorageSystem @relation(fields: [storageSystemId], references: [id], onDelete: Cascade)
  
  // Task metadata
  name            String?      // Optional user-friendly name
  status          TaskStatus   @default(PENDING)
  queuePosition   Int          @default(0)
  
  // Delivery configuration
  deliveryMethod  DeliveryMethod
  packingMode     PackingMode  @default(OPTIMIZED)
  
  // For DROP_TO_PLAYER / SHULKER_DROP
  targetPlayer    String?      // Minecraft username to drop items to
  
  // For PUT_IN_CHEST / SHULKER_CHEST - location to walk to (chest within 4 blocks)
  deliveryX       Int?
  deliveryY       Int?
  deliveryZ       Int?
  
  // Progress tracking
  currentStep     String?      // Current action description
  totalItems      Int          @default(0)
  collectedItems  Int          @default(0)
  
  // Error handling
  errorMessage    String?
  requiresInput   Boolean      @default(false) // True when waiting for user decision
  
  // Shulker tracking - IDs of empty shulkers selected by user
  selectedShulkerIds String[]  @default([])
  shulkersNeeded  Int          @default(0)
  shulkersFilled  Int          @default(0)
  
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  completedAt     DateTime?
  
  items           RequestItem[]
  
  @@index([botId])
  @@index([status])
  @@index([queuePosition])
}

model RequestItem {
  id            String      @id @default(uuid())
  taskId        String
  task          RequestTask @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  // Item info
  itemId        String      // minecraft item id
  itemName      String      // display name
  requestedCount Int        // how many the user requested
  collectedCount Int        @default(0) // how many have been collected
  
  // Source locations (cached from when task was created)
  sourceLocations Json      // Array of { chestId, x, y, z, slot, available }
  
  // Status
  status        String      @default("pending") // pending, collecting, partial, complete, skipped, failed
  errorMessage  String?
  
  // User decision for partial availability
  userDecision  String?     // "take_available", "skip", null (waiting)
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  @@index([taskId])
  @@index([status])
}

// ============ WORKFLOWS ============

enum WorkflowStatus {
  DRAFT       // Not yet activated
  ACTIVE      // Ready to run on triggers
  PAUSED      // Temporarily disabled
  ARCHIVED    // No longer in use
}

enum WorkflowExecutionStatus {
  PENDING     // Waiting to start
  WAITING     // Waiting for trigger event
  RUNNING     // Currently executing
  PAUSED      // Paused mid-execution
  COMPLETED   // Successfully finished
  FAILED      // Failed with error
  CANCELLED   // Cancelled by user
}

model Workflow {
  id          String         @id @default(uuid())
  userId      String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  name        String
  description String?
  status      WorkflowStatus @default(DRAFT)
  
  // Workflow definition stored as JSON (nodes, edges, viewport)
  definition  Json           // { nodes: [], edges: [], viewport: {} }
  
  // Trigger configuration (extracted for efficient querying)
  triggerType String?        // "schedule", "bot_event", "manual", "webhook"
  triggerConfig Json?        // Trigger-specific configuration
  
  // Schedule trigger (cron expression)
  cronExpression String?
  nextRunAt      DateTime?
  
  // Webhook trigger
  webhookToken   String?     @unique
  
  // Stats
  lastRunAt      DateTime?
  runCount       Int         @default(0)
  successCount   Int         @default(0)
  failureCount   Int         @default(0)
  
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  executions  WorkflowExecution[]
  
  @@index([userId])
  @@index([status])
  @@index([triggerType])
  @@index([nextRunAt])
}

model WorkflowExecution {
  id          String                  @id @default(uuid())
  workflowId  String
  workflow    Workflow                @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  
  status      WorkflowExecutionStatus @default(PENDING)
  
  // Trigger info
  triggeredBy String                  // "schedule", "bot_event", "manual", "webhook"
  triggerData Json?                   // Data from trigger (e.g., bot event payload)
  
  // Execution context
  context     Json                    @default("{}") // Variables, intermediate data
  currentNodeId String?               // Currently executing node
  
  // Results
  errorMessage String?
  errorNodeId  String?                // Node that caused the error
  
  startedAt   DateTime                @default(now())
  completedAt DateTime?
  
  logs        WorkflowExecutionLog[]
  
  @@index([workflowId])
  @@index([status])
  @@index([startedAt])
}

model WorkflowExecutionLog {
  id          String            @id @default(uuid())
  executionId String
  execution   WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  
  nodeId      String            // Node that generated this log
  nodeName    String?           // Node display name for readability
  nodeType    String            // Node type (trigger, action, logic, etc.)
  
  level       String            @default("info") // "debug", "info", "warn", "error"
  message     String
  data        Json?             // Additional structured data
  
  // Input/output for debugging
  inputData   Json?
  outputData  Json?
  
  duration    Int?              // Execution time in ms
  
  createdAt   DateTime          @default(now())
  
  @@index([executionId])
  @@index([nodeId])
  @@index([createdAt])
}
